Q)  Missing Number(Leetcode)

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

Example 1:

Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
Example 2:

Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.


****** Brute Force ******

class Solution {
    public int missingNumber(int[] nums) {

      int N = nums.length ;
      for (int i = 0; i <= N; i++) 
      {
            int flag = 0;
            for (int j = 0; j < N ; j++) 
            {
                if (nums[j] == i) 
                {
                    flag = 1;
                    break;
                }
            }

            if (flag == 0) return i;
        }

        // The following line will never execute. It is just to avoid warnings.
        return -1;

    }
}

Time Complexity: O(N^2)
Space Complexity: O(1)


****** Better Approach ******

class Solution {
    public int missingNumber(int[] nums) {
        
        int n = nums.length;
        int hash[] = new int[n+1];
        
        for(int i = 0 ; i < n ; i++)
            hash[nums[i]] ++ ;
        
        for(int i = 0 ; i <= n  ; i++ )
        {
            if(hash[i] == 0)
                return i ;
        }
        
        return -1;
    }
}

Time Complexity: O(N) + O(N) ~ O(2*N)
Space Complexity: O(N)


****** Optimised Approach ******

class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;

    int Totalsum = (n * (n + 1)) / 2;
       
        int sum=0;
        
        for(int i=0;i<n;i++) 
            sum+= nums[i];

        return Totalsum - sum;
    }
}

ime Complexity: O(N)
Space Complexity: O(1) 
